#######################################################################
# S3MetadataSitePostWritePlugin - This plugin generates a metadata
#                                 map useful for sites being deployed
#                                 to AWS S3.
#
# I wrote this for deploying my personal site, so it may not be
# suitable for more general use. YMMV. Happy hacking! -James
#
# * Generates a set of metadata for each "page" resource in the site
# * Sets the Content-Type header if a "mime-type" variable is set in
#   YAML front matter
#
# * Sets S3 object metadata based on YAML front matter -- YAML
#   variables of the form "HTTP-<Metadata-Key>: value" can then be
#   transformed to "Metadata-Key=value" when copying to S3
#
# * It also sets the text/html MIME type for extensionless HTML
#   files, as determined by checking the output_ext variable for each
#   page. Note that you will need the CleanUrlPagePostWritePlugin or
#   some other way to generate extensionless HTML during a site build
#   or you will be unable to take advantage of this feature
#
# Copyright 2017 James Kearney
# License: MIT License
#######################################################################
module S3MetadataSitePostWritePlugin
require 'json'

VERSION = "2.0.0"

MIME_TYPE_HTML = "text/html"
MIME_TYPE_APPLICATION = "application/octet-stream"
MIME_TYPE_FRONT_MATTER_VAR = "mime-type"

HTTP_METADATA_PREFIX = "HTTP-"
HTTP_CONTENT_TYPE_HEADER = "HTTP-Content-Type"

class MimeTypePageHelper

  def self.is_html_page?(page)
    if !(/\.htm.?$/.match(page.output_ext).nil?) then
      true
    else
      false
    end
  end

  def self.has_clean_permalink?(page)
    # match only permalinks that do NOT end in a "/"
    if ((/\.htm.?$/.match(page.url).nil?) && (/\/$/.match(page.url).nil?)) then
      true
    else
      false
    end
  end

  def self.get_mime_type(page)
    # The MIME type for this page is either the one specified in the front matter
    # or 'text/html' if the front matter does not specify one and the file was
    # written to disk as HTML

    page_mimetype = page.data['mime-type']      
    if (!page_mimetype.nil? && !page_mimetype.empty?) then
      return page_mimetype
    elsif is_html_page?(page) then
      return MIME_TYPE_HTML
    else
      return MIME_TYPE_APPLICATION
    end
  end

  def self.override_mime_type?(page)
    # If the file extention was html and the permalink does not specify this, we'll need
    # to write the MIME type to the map file

    retval = false

    if is_html_page?(page) && has_clean_permalink?(page) then
      retval = true
    else
      page_mimetype = page.data[MIME_TYPE_FRONT_MATTER_VAR]      
      if (!page_mimetype.nil? && !page_mimetype.empty?) then
        retval = true
      end
    end

    retval
  end
end

Jekyll::Hooks.register :site, :post_write do |site|
  metadatamap = Hash.new
  resources = Hash.new

  metadatamap[:comment] = "Generated by S3MetadataSitePostWritePlugin v" + VERSION
  metadatamap[:version] = VERSION
  
  basePath = site.dest

  site.pages.each { |page|
    print " Processing page:" + page.url + "\n"

    page_metadata = Hash.new
    page_fileName = page.destination(basePath)
    page_fileName.sub!(/#{basePath}/,"") # we want paths relative to the site root

    # If an HTML page has a clean permalink, then its ".html" will be removed later by the CleanUrlPagePostWritePlugin, so we need to adjust the filename in the metadata map
    if (MimeTypePageHelper.is_html_page?(page) && MimeTypePageHelper.has_clean_permalink?(page)) then
      page_fileName = page_fileName.slice(0,page_fileName.rindex("."))
    end

    page_metadata['fileName'] = page_fileName

    # Add MIME type from 'mime-type' front matter variable or
    # auto-generate if needed (i.e. file is extensionless HTML)
    if (MimeTypePageHelper.override_mime_type?(page)) then
      page_mimetype = MimeTypePageHelper.get_mime_type(page)
      print "  adding mimetype '" + page_mimetype + "'\n"
      page_metadata[HTTP_CONTENT_TYPE_HEADER] = page_mimetype
    end

    # Add/Update user-specified HTTP metadata
    # REMINDER: Using a HTTP-Content-Type YAML front matter variable will
    #           override any value specified in the 'mime-type' YAML front
    #           matter variable and any auto-generated value from the code
    #           earlier in this method
    s3_page_meta = page.data.select { |key, value| key.to_s.match(/^#{HTTP_METADATA_PREFIX}*/) }
    s3_page_meta.each do |key, value|
      print "  adding HTTP metadata: '" + key.to_s + ": " + value.to_s + "'\n"
      page_metadata[key] = value
    end

    resources[page.url] = page_metadata
  }

  metadatamap[:resources] = resources

  File.open(site.dest + "/" + "site-s3-metadata.json", "w") do |mapfile|
      mapfile.puts (JSON.generate(metadatamap))
  end
end

end
